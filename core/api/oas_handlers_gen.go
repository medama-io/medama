// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"

	"github.com/go-faster/errors"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

func recordError(string, error) {}

// handleDeleteUserRequest handles delete-user operation.
//
// Delete a user account.
//
// DELETE /user
func (s *Server) handleDeleteUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteUser",
			ID:   "delete-user",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "DeleteUser", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteUser",
			OperationSummary: "Delete User",
			OperationID:      "delete-user",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteUserParams
			Response = DeleteUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteUserResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteWebsitesIDRequest handles delete-websites-id operation.
//
// Delete a website.
//
// DELETE /websites/{hostname}
func (s *Server) handleDeleteWebsitesIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "DeleteWebsitesID",
			ID:   "delete-websites-id",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "DeleteWebsitesID", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeDeleteWebsitesIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response DeleteWebsitesIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "DeleteWebsitesID",
			OperationSummary: "Delete Website",
			OperationID:      "delete-websites-id",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteWebsitesIDParams
			Response = DeleteWebsitesIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteWebsitesIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.DeleteWebsitesID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.DeleteWebsitesID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeDeleteWebsitesIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetEventPingRequest handles get-event-ping operation.
//
// Ping endpoint to determine if the user is unique or not.
//
// GET /event/ping
func (s *Server) handleGetEventPingRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetEventPing",
			ID:   "get-event-ping",
		}
	)
	params, err := decodeGetEventPingParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetEventPingRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetEventPing",
			OperationSummary: "Ping",
			OperationID:      "get-event-ping",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "If-Modified-Since",
					In:   "header",
				}: params.IfModifiedSince,
				{
					Name: "u",
					In:   "query",
				}: params.U,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetEventPingParams
			Response = GetEventPingRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetEventPingParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetEventPing(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetEventPing(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetEventPingResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetUserRequest handles get-user operation.
//
// Retrieve the information of the user with the matching user ID.
//
// GET /user
func (s *Server) handleGetUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetUser",
			ID:   "get-user",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetUser", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetUser",
			OperationSummary: "Get User Info",
			OperationID:      "get-user",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetUserParams
			Response = GetUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetUser(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetUser(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetUserResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDBrowsersRequest handles get-website-id-browsers operation.
//
// Get a list of browsers and their stats.
//
// GET /website/{hostname}/browsers
func (s *Server) handleGetWebsiteIDBrowsersRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDBrowsers",
			ID:   "get-website-id-browsers",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDBrowsers", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDBrowsersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDBrowsersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDBrowsers",
			OperationSummary: "Get Browser Stats",
			OperationID:      "get-website-id-browsers",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDBrowsersParams
			Response = GetWebsiteIDBrowsersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDBrowsersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDBrowsers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDBrowsers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDBrowsersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDCampaignsRequest handles get-website-id-campaigns operation.
//
// Get a list of UTM campaigns and their stats.
//
// GET /website/{hostname}/campaigns
func (s *Server) handleGetWebsiteIDCampaignsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDCampaigns",
			ID:   "get-website-id-campaigns",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDCampaigns", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDCampaignsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDCampaignsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDCampaigns",
			OperationSummary: "Get UTM Campaign Stats",
			OperationID:      "get-website-id-campaigns",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDCampaignsParams
			Response = GetWebsiteIDCampaignsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDCampaignsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDCampaigns(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDCampaigns(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDCampaignsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDCountryRequest handles get-website-id-country operation.
//
// Get a list of countries and their stats.
//
// GET /website/{hostname}/countries
func (s *Server) handleGetWebsiteIDCountryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDCountry",
			ID:   "get-website-id-country",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDCountry", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDCountryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDCountryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDCountry",
			OperationSummary: "Get Country Stats",
			OperationID:      "get-website-id-country",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDCountryParams
			Response = GetWebsiteIDCountryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDCountryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDCountry(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDCountry(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDCountryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDDeviceRequest handles get-website-id-device operation.
//
// Get a list of devices and their stats.
//
// GET /website/{hostname}/devices
func (s *Server) handleGetWebsiteIDDeviceRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDDevice",
			ID:   "get-website-id-device",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDDevice", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDDeviceParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDDeviceRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDDevice",
			OperationSummary: "Get Device Stats",
			OperationID:      "get-website-id-device",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDDeviceParams
			Response = GetWebsiteIDDeviceRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDDeviceParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDDevice(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDDevice(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDDeviceResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDLanguageRequest handles get-website-id-language operation.
//
// Get a list of languages and their stats.
//
// GET /website/{hostname}/languages
func (s *Server) handleGetWebsiteIDLanguageRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDLanguage",
			ID:   "get-website-id-language",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDLanguage", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDLanguageParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDLanguageRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDLanguage",
			OperationSummary: "Get Language Stats",
			OperationID:      "get-website-id-language",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDLanguageParams
			Response = GetWebsiteIDLanguageRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDLanguageParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDLanguage(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDLanguage(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDLanguageResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDMediumsRequest handles get-website-id-mediums operation.
//
// Get a list of UTM mediums and their stats.
//
// GET /website/{hostname}/mediums
func (s *Server) handleGetWebsiteIDMediumsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDMediums",
			ID:   "get-website-id-mediums",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDMediums", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDMediumsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDMediumsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDMediums",
			OperationSummary: "Get UTM Medium Stats",
			OperationID:      "get-website-id-mediums",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDMediumsParams
			Response = GetWebsiteIDMediumsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDMediumsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDMediums(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDMediums(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDMediumsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDOsRequest handles get-website-id-os operation.
//
// Get a list of OS and their stats.
//
// GET /website/{hostname}/os
func (s *Server) handleGetWebsiteIDOsRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDOs",
			ID:   "get-website-id-os",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDOs", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDOsParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDOsRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDOs",
			OperationSummary: "Get OS Stats",
			OperationID:      "get-website-id-os",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDOsParams
			Response = GetWebsiteIDOsRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDOsParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDOs(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDOs(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDOsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDPagesRequest handles get-website-id-pages operation.
//
// Get a list of pages and their stats.
//
// GET /website/{hostname}/pages
func (s *Server) handleGetWebsiteIDPagesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDPages",
			ID:   "get-website-id-pages",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDPages", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDPagesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDPagesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDPages",
			OperationSummary: "Get Page Stats",
			OperationID:      "get-website-id-pages",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDPagesParams
			Response = GetWebsiteIDPagesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDPagesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDPages(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDPages(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDPagesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDReferrersRequest handles get-website-id-referrers operation.
//
// Get a list of referrers and their stats.
//
// GET /website/{hostname}/referrers
func (s *Server) handleGetWebsiteIDReferrersRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDReferrers",
			ID:   "get-website-id-referrers",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDReferrers", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDReferrersParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDReferrersRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDReferrers",
			OperationSummary: "Get Referrer Stats",
			OperationID:      "get-website-id-referrers",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDReferrersParams
			Response = GetWebsiteIDReferrersRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDReferrersParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDReferrers(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDReferrers(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDReferrersResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDSourcesRequest handles get-website-id-sources operation.
//
// Get a list of UTM sources and their stats.
//
// GET /website/{hostname}/sources
func (s *Server) handleGetWebsiteIDSourcesRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDSources",
			ID:   "get-website-id-sources",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDSources", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDSourcesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDSourcesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDSources",
			OperationSummary: "Get UTM Source Stats",
			OperationID:      "get-website-id-sources",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDSourcesParams
			Response = GetWebsiteIDSourcesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDSourcesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDSources(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDSources(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDSourcesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDSummaryRequest handles get-website-id-summary operation.
//
// Get a summary of the website's stats.
//
// GET /website/{hostname}/summary
func (s *Server) handleGetWebsiteIDSummaryRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDSummary",
			ID:   "get-website-id-summary",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDSummary", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDSummaryParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDSummaryRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDSummary",
			OperationSummary: "Get Stat Summary",
			OperationID:      "get-website-id-summary",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "previous",
					In:   "query",
				}: params.Previous,
				{
					Name: "interval",
					In:   "query",
				}: params.Interval,
				{
					Name: "stat",
					In:   "query",
				}: params.Stat,
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDSummaryParams
			Response = GetWebsiteIDSummaryRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDSummaryParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDSummary(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDSummary(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDSummaryResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsiteIDTimeRequest handles get-website-id-time operation.
//
// Get a list of pages and their time stats.
//
// GET /website/{hostname}/time
func (s *Server) handleGetWebsiteIDTimeRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsiteIDTime",
			ID:   "get-website-id-time",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsiteIDTime", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsiteIDTimeParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsiteIDTimeRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsiteIDTime",
			OperationSummary: "Get Time Stats",
			OperationID:      "get-website-id-time",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
				{
					Name: "start",
					In:   "query",
				}: params.Start,
				{
					Name: "end",
					In:   "query",
				}: params.End,
				{
					Name: "path",
					In:   "query",
				}: params.Path,
				{
					Name: "referrer",
					In:   "query",
				}: params.Referrer,
				{
					Name: "utm_source",
					In:   "query",
				}: params.UtmSource,
				{
					Name: "utm_medium",
					In:   "query",
				}: params.UtmMedium,
				{
					Name: "utm_campaign",
					In:   "query",
				}: params.UtmCampaign,
				{
					Name: "browser",
					In:   "query",
				}: params.Browser,
				{
					Name: "os",
					In:   "query",
				}: params.Os,
				{
					Name: "device",
					In:   "query",
				}: params.Device,
				{
					Name: "country",
					In:   "query",
				}: params.Country,
				{
					Name: "language",
					In:   "query",
				}: params.Language,
				{
					Name: "limit",
					In:   "query",
				}: params.Limit,
				{
					Name: "offset",
					In:   "query",
				}: params.Offset,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsiteIDTimeParams
			Response = GetWebsiteIDTimeRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsiteIDTimeParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsiteIDTime(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsiteIDTime(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsiteIDTimeResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsitesRequest handles get-websites operation.
//
// Get a list of all websites from the user.
//
// GET /websites
func (s *Server) handleGetWebsitesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsites",
			ID:   "get-websites",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsites", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsitesParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsitesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsites",
			OperationSummary: "List Websites",
			OperationID:      "get-websites",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "summary",
					In:   "query",
				}: params.Summary,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsitesParams
			Response = GetWebsitesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsitesParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsites(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsites(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsitesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetWebsitesIDRequest handles get-websites-id operation.
//
// Get website details for an individual website.
//
// GET /websites/{hostname}
func (s *Server) handleGetWebsitesIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "GetWebsitesID",
			ID:   "get-websites-id",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "GetWebsitesID", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodeGetWebsitesIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response GetWebsitesIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "GetWebsitesID",
			OperationSummary: "Get Website",
			OperationID:      "get-websites-id",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetWebsitesIDParams
			Response = GetWebsitesIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetWebsitesIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetWebsitesID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetWebsitesID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeGetWebsitesIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePatchUserRequest handles patch-user operation.
//
// Update a user account's details.
//
// PATCH /user
func (s *Server) handlePatchUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PatchUser",
			ID:   "patch-user",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "PatchUser", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePatchUserParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePatchUserRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PatchUserRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PatchUser",
			OperationSummary: "Update User Info",
			OperationID:      "patch-user",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
			},
			Raw: r,
		}

		type (
			Request  = *UserPatch
			Params   = PatchUserParams
			Response = PatchUserRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPatchUserParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PatchUser(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PatchUser(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePatchUserResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePatchWebsitesIDRequest handles patch-websites-id operation.
//
// Update a website's information.
//
// PATCH /websites/{hostname}
func (s *Server) handlePatchWebsitesIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PatchWebsitesID",
			ID:   "patch-websites-id",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "PatchWebsitesID", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	params, err := decodePatchWebsitesIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePatchWebsitesIDRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PatchWebsitesIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PatchWebsitesID",
			OperationSummary: "Update Website",
			OperationID:      "patch-websites-id",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
				{
					Name: "hostname",
					In:   "path",
				}: params.Hostname,
			},
			Raw: r,
		}

		type (
			Request  = *WebsitePatch
			Params   = PatchWebsitesIDParams
			Response = PatchWebsitesIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPatchWebsitesIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PatchWebsitesID(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PatchWebsitesID(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePatchWebsitesIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostAuthLoginRequest handles post-auth-login operation.
//
// Login to the service and retrieve a session token for authentication.
//
// POST /auth/login
func (s *Server) handlePostAuthLoginRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostAuthLogin",
			ID:   "post-auth-login",
		}
	)
	request, close, err := s.decodePostAuthLoginRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostAuthLoginRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostAuthLogin",
			OperationSummary: "Login",
			OperationID:      "post-auth-login",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *AuthLogin
			Params   = struct{}
			Response = PostAuthLoginRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostAuthLogin(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostAuthLogin(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostAuthLoginResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostAuthLogoutRequest handles post-auth-logout operation.
//
// Logout of the service and destroy the session token.
//
// POST /auth/logout
func (s *Server) handlePostAuthLogoutRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostAuthLogout",
			ID:   "post-auth-logout",
		}
	)
	params, err := decodePostAuthLogoutParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response PostAuthLogoutRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostAuthLogout",
			OperationSummary: "Logout",
			OperationID:      "post-auth-logout",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "_me_sess",
					In:   "cookie",
				}: params.MeSess,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = PostAuthLogoutParams
			Response = PostAuthLogoutRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPostAuthLogoutParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostAuthLogout(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostAuthLogout(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostAuthLogoutResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostEventHitRequest handles post-event-hit operation.
//
// Send a hit event to register a user view or interaction.
//
// POST /event/hit
func (s *Server) handlePostEventHitRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostEventHit",
			ID:   "post-event-hit",
		}
	)
	params, err := decodePostEventHitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePostEventHitRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostEventHitRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostEventHit",
			OperationSummary: "Send Hit Event",
			OperationID:      "post-event-hit",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "User-Agent",
					In:   "header",
				}: params.UserAgent,
				{
					Name: "Accept-Language",
					In:   "header",
				}: params.AcceptLanguage,
			},
			Raw: r,
		}

		type (
			Request  = EventHit
			Params   = PostEventHitParams
			Response = PostEventHitRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPostEventHitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostEventHit(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostEventHit(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostEventHitResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePostWebsitesRequest handles post-websites operation.
//
// Add a new website.
//
// POST /websites
func (s *Server) handlePostWebsitesRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: "PostWebsites",
			ID:   "post-websites",
		}
	)
	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			sctx, ok, err := s.securityCookieAuth(ctx, "PostWebsites", r)
			if err != nil {
				err = &ogenerrors.SecurityError{
					OperationContext: opErrContext,
					Security:         "CookieAuth",
					Err:              err,
				}
				defer recordError("Security:CookieAuth", err)
				s.cfg.ErrorHandler(ctx, w, r, err)
				return
			}
			if ok {
				satisfied[0] |= 1 << 0
				ctx = sctx
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			err = &ogenerrors.SecurityError{
				OperationContext: opErrContext,
				Err:              ogenerrors.ErrSecurityRequirementIsNotSatisfied,
			}
			defer recordError("Security", err)
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
	}
	request, close, err := s.decodePostWebsitesRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response PostWebsitesRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    "PostWebsites",
			OperationSummary: "Add Website",
			OperationID:      "post-websites",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *WebsiteCreate
			Params   = struct{}
			Response = PostWebsitesRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PostWebsites(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.PostWebsites(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodePostWebsitesResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
